#!/usr/bin/env bash

NAME=${0##*/}
ROOT="" # ensure that we're not reading ROOT from the environment

usage() {
  cat << EOF
usage: $NAME [ROOT]

Generates a kernel cmdline string from /etc/cmdline and /etc/cmdline.d/
Optionally reads from an alternate root directory at ROOT.

  Options:
    -h,--help       Print this help message

EOF
  exit 0
}

invalid_option() {
  >&2 echo "$NAME: unrecognized option '$1'"
  >&2 echo "Try '$NAME --help' for more information"
  exit 1
}

invalid_dir() {
  >&2 echo "$NAME: $1: No such file or directory"
  exit 1
}

# Loop over arugments
while [[ -n "$1" ]]; do
  case "$1" in
    -h | --help )
      usage
      ;;
    -* )
      invalid_option "$1"
      ;;
    * )
      if [[ -n "$ROOT" ]]; then
        invalid_option "$1"
      fi
      ROOT="$1"
      ;;
  esac
  shift
done

# Normalize ROOT path
ROOT="$(realpath -Lmqs "$ROOT")"

# Ensure ROOT is valid
if [[ -n "$ROOT" && ! -d "$ROOT" ]]; then
  invalid_dir "$ROOT"
elif [[ ! -d "$ROOT/etc" ]]; then
  invalid_dir "$ROOT/etc"
fi

# Generate cmdline string
# Use echo and subshell to normalize whitespace and concatenate to a space delimited
# single line
echo `cat $ROOT/etc/cmdline $ROOT/etc/cmdline.d/* 2>/dev/null | sed 's/#.*$//'`
